
You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.

Given an integer array flowerbed containing 0''s and 1''s, where 0 means empty and 1 means not empty, and an integer x, return if x new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.

Input Format
The first line of input contains a 2 space separated integers n and x.

The next line of input contains n space seperated integers.

Output Format
Return if x new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.

Example 1
Input

5 1
1 0 0 0 1
Output

true
Explanation

We can easily plant 1 tree at any of the index.

Example 2
Input

5 2
1 0 0 0 1
Output

false
Explanation

It is impossible to plant 2 tress such that no tree should be adjacent.




import java.util.*;

public class Main{
    public static void main(String[] args)
    {
        int n,x;
        Scanner in = new Scanner(System.in);
	    n = in.nextInt();
        x = in.nextInt();
        int flowerbed[]=new int[n];
        for(int i=0;i<n;i++)
        flowerbed[i]=in.nextInt();
        Solution obj=new Solution();
        Boolean ans=(obj.solve(flowerbed,x));
        if(ans==true)
        System.out.println("true");
        else
        System.out.println("false");
    }
    
}

class Solution {
    static Boolean solve(int flowerbed[], int x) {
        int n = flowerbed.length;

        for (int i = 0; i < n; i++) {
            if (flowerbed[i] == 0) {
                boolean leftEmpty = (i == 0 || flowerbed[i - 1] == 0);
                boolean rightEmpty = (i == n - 1 || flowerbed[i + 1] == 0);

                if (leftEmpty && rightEmpty) {
                    flowerbed[i] = 1; // plant flower
                    x--;              // reduce count
                    if (x <= 0) return true;
                }
            }
        }
        return x <= 0;
    }
}
