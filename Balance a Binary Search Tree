Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1

Input Format
The First line contains space- separated integers denoting the nodes of the binary tree, where -1 indicates that the NULL pointer represented by N has been appointed to the previous node

The input is given in a preorder way, that is, the node then left subtree, and then right subtree as shown in the example.

Output Format
Return the root of the balanced tree, the driver code will verify it.

Example 1
Input

image

1 N 2 N 3 N 4 N N
Output

1
Explanation

2 1 3 N N N 4 is not the only correct answer, [3,1,4,null,2] is also correct.

import java.util.*;
import java.io.*;

class Node {
    int data;
    Node left;
    Node right;
    Node(int data) {
        this.data = data;
        left = null;
        right = null;
    }
}

class Main {

    static Node buildTree(String str) {
        if (str.length() == 0 || str.charAt(0) == 'N') {
            return null;
        }

        String ip[] = str.split(" ");
        Node root = new Node(Integer.parseInt(ip[0]));
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);

        int i = 1;
        while (!queue.isEmpty() && i < ip.length) {
            Node currNode = queue.poll();
            String currVal = ip[i];

            if (!currVal.equals("N")) {
                currNode.left = new Node(Integer.parseInt(currVal));
                queue.add(currNode.left);
            }
            i++;
            if (i >= ip.length) break;
            currVal = ip[i];
            if (!currVal.equals("N")) {
                currNode.right = new Node(Integer.parseInt(currVal));
                queue.add(currNode.right);
            }
            i++;
        }
        return root;
    }

    public static boolean isBalanced(Node root) {
        if (root == null) return true;
        if (!isBalanced(root.left) || !isBalanced(root.right)) return false;
        return Math.abs(height(root.left) - height(root.right)) <= 1;
    }

    public static int height(Node root) {
        if (root == null) return 0;
        return Math.max(height(root.left), height(root.right)) + 1;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br =
            new BufferedReader(new InputStreamReader(System.in));
        String s = br.readLine();
        Node root = buildTree(s);

        Solution g = new Solution();
        root = g.balanceBST(root);

        boolean ans = isBalanced(root);
        if (ans) System.out.println(1);
        else System.out.println(0);
    }
}

class Solution {

    // Helper function for inorder traversal
    private void inorder(Node root, List<Integer> list) {
        if (root == null) return;
        inorder(root.left, list);
        list.add(root.data);
        inorder(root.right, list);
    }

    // Helper function to construct balanced BST from sorted list
    private Node buildBalanced(List<Integer> list, int start, int end) {
        if (start > end) return null;
        int mid = (start + end) / 2;
        Node root = new Node(list.get(mid));
        root.left = buildBalanced(list, start, mid - 1);
        root.right = buildBalanced(list, mid + 1, end);
        return root;
    }

    public Node balanceBST(Node root) {
        List<Integer> inorderList = new ArrayList<>();
        inorder(root, inorderList);
        return buildBalanced(inorderList, 0, inorderList.size() - 1);
    }
}
