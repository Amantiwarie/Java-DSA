
The circular queue is a type of linear data structure that follows the FIFO principle, where the first element added to the queue is the first one to be removed. It is also referred to as a "Ring Buffer". The advantage of using a circular queue is that it allows for the utilization of space in front of the queue. In contrast, a traditional queue will not allow for additional elements to be added once it reaches capacity, while a circular queue can utilize the empty space at the front to store new elements.

Implement the AccioQueue class:

AccioQueue(k) Initializes the object with the size of the queue to be k.
int Front() Gets the front item from the queue. If the queue is empty, return -1.
int Rear() Gets the last item from the queue. If the queue is empty, return -1.
boolean enQueue(int value) Inserts an element into the circular queue. Return true if the operation is successful.
boolean deQueue() Deletes an element from the circular queue. Return true if the operation is successful.
boolean isEmpty() Checks whether the circular queue is empty or not.
boolean isFull() Checks whether the circular queue is full or not. You must solve the problem without using the built-in queue data structure in your programming language.
Input Format
A integer N denoting number of queries.

A query can be one of the following types:

0 X --> Calls AccioQueue(X)

1 → Front()

2 → Rear()

3 X → enQueue(int value)

4 → deQueue()

5 → isEmpty()

6 → isFull()

Output Format
Print null for query 0 , an integer for query 1 and 2 or true and false for query 3, 4 , 5, 6.

Example 1
Input

10
0 3
3 1
3 2
3 3
3 4
2
6
4
3 4
2

Output

null  true  true  true  false  3  true  true  true  4









import java.util.*;
import java.lang.*;
import java.io.*;

class AccioQueue {
    private int[] arr;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    public AccioQueue(int k) {
        capacity = k;
        arr = new int[k];
        front = -1;
        rear = -1;
        size = 0;
    }

    public int Front() {
        if (isEmpty()) return -1;
        return arr[front];
    }

    public int Rear() {
        if (isEmpty()) return -1;
        return arr[rear];
    }

    public boolean enQueue(int value) {
        if (isFull()) return false;
        if (isEmpty()) {
            front = 0;
            rear = 0;
        } else {
            rear = (rear + 1) % capacity;
        }
        arr[rear] = value;
        size++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) return false;
        if (front == rear) { // Only one element
            front = -1;
            rear = -1;
        } else {
            front = (front + 1) % capacity;
        }
        size--;
        return true;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}

public class Main {
    public static void main(String[] args) throws java.lang.Exception {
        Scanner sc = new Scanner(System.in);
        int q = sc.nextInt();
        AccioQueue queue = null;

        for (int i = 0; i < q; i++) {
            int query = sc.nextInt();

            switch (query) {
                case 0: // initialize queue
                    int k = sc.nextInt();
                    queue = new AccioQueue(k);
                    System.out.print("null ");
                    break;
                case 1: // Front
                    System.out.print(queue.Front() + " ");
                    break;
                case 2: // Rear
                    System.out.print(queue.Rear() + " ");
                    break;
                case 3: // enQueue
                    int val = sc.nextInt();
                    System.out.print(queue.enQueue(val) + " ");
                    break;
                case 4: // deQueue
                    System.out.print(queue.deQueue() + " ");
                    break;
                case 5: // isEmpty
                    System.out.print(queue.isEmpty() + " ");
                    break;
                case 6: // isFull
                    System.out.print(queue.isFull() + " ");
                    break;
            }
        }
        sc.close();
    }
}

























Explanation

AccioQueue AccioQueue = new AccioQueue(3);

AccioQueue.enQueue(1); // return True

AccioQueue.enQueue(2); // return True

AccioQueue.enQueue(3); // return True

AccioQueue.enQueue(4); // return False

AccioQueue.Rear(); // return 3

AccioQueue.isFull(); // return True

AccioQueue.deQueue(); // return True

AccioQueue.enQueue(4); // return True

AccioQueue.Rear(); // return 4
